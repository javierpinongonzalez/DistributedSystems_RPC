/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#include "lib.h"
#include "rpcchat.h"

void sendMessage(message,Host);

Host server;
User config;
static pthread_mutex_t mtx_alarm = PTHREAD_MUTEX_INITIALIZER;	
static pthread_mutex_t mtx_tstamp= PTHREAD_MUTEX_INITIALIZER;	


void *thread_update_messages(void *arg) {
	int result = strlen(arg);
	int bool =  10;
	while ( bool == 10 ) {
		result = pthread_mutex_lock(&mtx_alarm);
		if ( result != 0 ) {
			printf("ERROR / No se pudo bloquear el recurso. \n");
			close_error();
		} else {
			getMessages();
			alarm(1);
		}
	}
	pthread_exit(NULL);
}

int main (int argc, char *argv[]) {
	signal(SIGALRM,rsi_handler);
	signal(SIGINT,rsi_handler);
	signal(SIGTERM,rsi_handler);
	pthread_t thUpdateMessages;

	char buffer[100];

	if ( argc != 3 ) {
		close_error();
	}

	strcpy(server.host_addr, argv[1]);
	strcpy(config.nickname,argv[2]);
	int result = 0;
	result = pthread_create(&thUpdateMessages,NULL,thread_update_messages,"[INFO] Connecting chat...\n\0");
	if ( result != 0 ) {
		printf("ERROR / No se pudo lanzar el thread\n");
		close_error();
	}

	int readed_bytes;
	int menuEXIT = -10;
	while (menuEXIT == -10 ) {
		readed_bytes = 0;
		readed_bytes = read(0,&buffer,100);
		buffer[readed_bytes - 1] = '\0';
		menuEXIT = shellParser(buffer,config,server);
	}
	printf("\nBye bye.\n");
	close_correct();
	return 1;
}


void rsi_handler(int signal) {
	if ( signal == SIGALRM ) { pthread_mutex_unlock(&mtx_alarm); }
	if ( signal == SIGTERM || signal == SIGINT ) { close_correct(); }
}

int shellParser(char *string,User cfg, Host serv) {
	int EXIT = -10;
	
	if ( strcmp(string,":exitChat") == 0 ) {
		EXIT = 10;
	} else {
		message msg;
		msg.timestamp = 0;
		msg.operator= malloc(20 * sizeof(char));
		msg.message = malloc(100 * sizeof(char));
		strcpy(msg.operator,cfg.nickname);
		strcpy(msg.message,string);
	
		sendMessage(msg, serv);
		
		free(msg.operator);
		free(msg.message);
	}
	return EXIT;
}

void getMessages(void) {
	CLIENT *clnt;
	historic *result;
	long tstamp = config.msgNumber;
	if ( pthread_mutex_lock(&mtx_tstamp) == 0 ) {
		
		clnt = clnt_create (server.host_addr, rpcchat, CHATMESSAGING, "udp");
		if ( clnt == NULL ) {
			clnt_pcreateerror(server.host_addr);
			close_error();
		}
	
		result = getchat_1(&tstamp,clnt);
		if ( result == (historic *) NULL) {
			clnt_perror (clnt,"call failed");
			close_error();
		}		
		int i = 0;
		
		for ( i = 0; i< result->list.list_len; i++) {
			if ( strcmp(config.nickname,result->list.list_val[i].operator) != 0 ) {
				printf("%s: %s \n",result->list.list_val[i].operator,result->list.list_val[i].message);
			}
			if ( config.msgNumber < result->list.list_val[i].timestamp ) { config.msgNumber = result->list.list_val[i].timestamp; } 
		}
		
		clnt_destroy(clnt);
		pthread_mutex_unlock(&mtx_tstamp);
	}
	
	
}

void sendMessage(message msg, Host serv) {
	CLIENT *clnt;
	void *result;
	
	clnt = clnt_create(serv.host_addr, rpcchat, CHATMESSAGING, "udp");
	if ( clnt == NULL ) {
		clnt_pcreateerror (serv.host_addr);
		printf("ERROR / No se pudo enviar el mensaje\n");
		close_error();
	}
	result = writechat_1(&msg, clnt);
	if ( result == (void *) NULL ) {
		clnt_perror (clnt, "call fail");
		printf("ERROR / No se recibio respuesta del servidor\n");
		close_error();
	}
	clnt_destroy(clnt);
}
void close_correct() {
	printf("\n");
	pthread_mutex_destroy(&mtx_alarm);
	pthread_mutex_destroy(&mtx_tstamp);
	exit(EXIT_SUCCESS);
}
void close_error() {
	printf("\n");
	pthread_mutex_destroy(&mtx_alarm);
	pthread_mutex_destroy(&mtx_tstamp);
	exit(EXIT_FAILURE);
}

